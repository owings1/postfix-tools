#!/usr/bin/env python3
from __future__ import annotations

import fileinput
from argparse import ArgumentParser
from ipaddress import IPv4Network, IPv6Network, collapse_addresses, ip_network
from itertools import chain


class Parser(ArgumentParser):
    description = "Collapse CIDRs from files or stdin"
    usage = "Usage: cidrcollapse [OPTIONS] [FILE ...]"

    def add_arguments(self) -> None:
        arg = self.add_argument
        arg('files', nargs='*', help='Input files. If omitted, reads from stdin')
        arg('--sort', '-s', action='store_true', help='Sort the output')
        arg('--reverse', '-r', action='store_true', help='Reverse sort the output')
        arg('--compact', '-c', action='store_true', help='Omit prefix length for single addresses')

def nocomment(s: str) -> bool:
    return not s.startswith('#')

def compact(value: IPv4Network|IPv6Network) -> str:
    if value.num_addresses == 1:
        value, = value.hosts()
    return str(value)

def main(args=None) -> None:
    parser = Parser()
    parser.add_arguments()
    opts = parser.parse_args(args)
    opts.sort |= opts.reverse
    with fileinput.input(opts.files, encoding='utf-8') as file:
        it = map(str.strip, file)
        it = filter(None, it)
        it = filter(nocomment, it)
        it = map(ip_network, it)
        nets = list(it)
        it4 = filter(lambda x: isinstance(x, IPv4Network), nets)
        it6 = filter(lambda x: isinstance(x, IPv6Network), nets)
        it4 = collapse_addresses(it4)
        it6 = collapse_addresses(it6)
        fams = [list(it4), list(it6)]
    if opts.sort:
        for fam in fams:
            fam.sort(reverse=opts.reverse)
    if opts.reverse:
        fams.reverse()
    it = chain(*fams)
    if opts.compact:
        it = map(compact, it)
    else:
        it = map(str, it)
    print('\n'.join(it))

if __name__ == '__main__':
    main()
